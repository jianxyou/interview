<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Development Interview Preparation</title>
    <style>
        /* 核心样式 */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        h1 {
            text-align: center;
            margin-top: 2rem;
            color: #444;
        }

        #topics {
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: #fff;
            box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.1);
        }

        .topic {
            border-bottom: 1px solid #ddd;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
        }

        .topic:last-child {
            border-bottom: none;
        }

        .question {
            margin-top: 1rem;
        }

        .answer {
            display: none;
            background-color: #e8f3fd;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 0.5rem;
        }

        button {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: #007BFF;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>

<body>

    <h1>面试准备</h1>
    <section id="topics">
        <div class="topic">
            <h2>计算机基础</h2>

            <div class="question">
                <p>什么是操作系统？</p>
                <div class="answer">
                    <p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。
                        举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。操作系统存在屏蔽了硬件层的复杂性。
                        操作系统就像是硬件使用的负责人，统筹着各种相关事项。操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。
                        内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是用户态和内核态？？</p>
                <div class="answer">

                    <p>
                        为什么要区分用户态和内核态，因为我们不想有一些重要的指令可以随便被调用,当应用程序需要使用一些更高级别的操作比如说读写磁盘和网络通信的时候，这个时候就需要切换到内核态来处理这些东西。
                        只有一个内核态不行吗，这是不行的，因为cpu中有一些指令是非常强大且敏感的，比如内存分配，设置时钟，IO处理等，如果所有程序都能使用这些指令的话，会是非常的危险

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是系统调用</p>
                <div class="answer">
                    <P>
                        我们平常程序运行的时候自动都是在用户态的，当我们需要调用一些高级的功能的时候，这个时候就需要申请内核态的一些功能来帮我们进行调用了。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>什么是进城和线程</p>
                <div class="answer">
                    <P>
                        进程就是计算机正在运行的一个程序实例，比如我们打开的微信。
                        线程就是轻量级的进程，一个进程可以有多个线程，比如我们的微信允许我们接受新的消息。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>有了进程为什么还需要线程?</p>
                <div class="answer">
                    <P>进程切换是一个开销很大的操作，线程切换的成本较低。线程更轻量，一个进程可以创建多个线程。多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如
                        IO 阻塞就会挂起直到结果返回。同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。#
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么要用多线程</p>
                <div class="answer">
                    <p>
                        多核时代允许我们用多个cpu，如果有cpu放着不用的话那就是资源的浪费和损失
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是僵尸进程和孤儿进程？/p>
                <div class="answer">
                    <P>在 Unix/Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的
                        PCB，即使父进程结束了，子进程仍然可以继续运行。当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB
                        依然存在于系统中。这些信息只有在父进程调用 wait()或
                        waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB
                        仍然存在但父进程无法得到状态信息的情况）。僵尸进程：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或
                        waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB
                        依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或
                        waitpid()系统调用来回收子进程。孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用
                        wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init
                        进程来回收孤儿进程的资源。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是死锁，</p>
                <div class="answer">
                    <P>
                        process control block, 这个可以看作是进程的大脑，用来识别不同的进程，里面装了不同的进程的信息，比如进程的调度信息，进程的优先级，以及进程打开的文件信息等等。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是内存碎片</p>
                <div class="answer">
                    <p>
                        内存碎片分为两种，内部碎片和外部碎片。

                        内部碎片： 当我们给进程分配完内存以后，进程实际使用的内存要比我们分配的要少很多，这就导致了内部碎片。
                        外部碎片： 每个进程都会被分配一定的内存使用，假如我们给某个进程分配的内存块叫A，另一个叫B， A和B之间的连续内存不够再塞入一个C的话，那么这部分就叫做外部碎片

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是虚拟内存</p>
                <div class="answer">
                    <p>
                        虚拟内存是一片假想的空间，主要的目的是为了简化内存管理。
                        总的来说有以下几个作用。

                        1，提供更大的内存空间： 我们可以调用磁盘里面的内存帮忙有时候，因为毕竟有时候静态的内存有些不够用。
                        2，简化内存管理： 程序员就不用跟实际的内存打交道了，我们都是直接跟一致的虚拟内存打交道。
                        3，
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>虚拟地址是怎么和物理地址进行转换的</p>
                <div class="answer">
                    <p>
                        我们主要通过MMU进行转化，MMU转换的机制主要可以分为三种
                        1，分段。
                        2，分页: 我们的虚拟地址由页号和偏移组成， 我们找到和这个页相映射的物理页后，我们再加上一定的偏移，就可以完成
                        3，段页

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么分页容易造成内部碎片，分段容易造成外部碎片</p>
                <div class="answer">
                    <p>
                        页的大小是固定的，而段的大小是根据我们的进程来决定的。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>PCB 是什么？包含哪些信息？</p>
                <div class="answer">
                    <P>
                        process control block, 这个可以看作是进程的大脑，用来识别不同的进程，里面装了不同的进程的信息，比如进程的调度信息，进程的优先级，以及进程打开的文件信息等等。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>内存管理主要做了什么？？</p>
                <div class="answer">
                    <p>
                        内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free
                        函数：释放内存。地址转换：将程序中的虚拟地址转换成内存中的物理地址。内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。......
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是内存碎片？</p>
                <div class="answer">
                    <p>
                        内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2
                        的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63
                        字节的内存就成为了内部内存碎片。外部内存碎片(External Memory
                        Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>PCB 是什么？包含哪些信息？</p>
                <div class="answer">
                    <P>PCB（Process Control Block） 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB
                        视为进程的大脑。当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB
                        中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。PCB
                        主要包含下面几部分的内容：进程的描述信息，包括进程的名称、标识符等等；进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；进程对资源的需求情况，包括
                        CPU 时间、内存空间、I/O
                        设备等等。进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字
                        PSW、用户栈指针。......#
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>






            <div class="question">
                <p>#GET 和 POST 的区别</p>
                <div class="answer">
                    <p>
                        GET 和 POST 是 HTTP
                        协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：语义（主要区别）：GET
                        通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>PING 命令的作用是什么？</p>
                <div class="answer">
                    <p>
                        PING 命令的输出结果通常包括以下几部分信息：ICMP Echo Request（请求报文）信息：序列号、TTL（Time to Live）值。目标主机的域名或 IP
                        地址：输出结果的第一行。往返时间（RTT，Round-Trip Time）：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo
                        Reply（响应报文）的总时间，用来衡量网络连接的延迟。统计结果（Statistics）：包括发送的 ICMP 请求数据包数量、接收到的 ICMP
                        响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。如果 PING
                        对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对ICMP请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。#
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>DNS 的作用是什么？
                </p>
                <div class="answer">
                    <p>
                        DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。
                        在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么 DNS 就闪亮登场了。目前 DNS
                        的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，它可以在UDP或TCP协议之上运行，端口为 53 .



                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>TCP 与 UDP 的区别（重要）</p>
                <div class="answer">
                    <P>
                        tcp不用建立连接，udp不需要建立连接
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>应用层有哪些常见的协议</p>
                <div class="answer">
                    <p>
                        HTTP ： 超文本传输协议。
                        SMTP： 邮件传输协议。
                        FTP：文件传输协议
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>传输层有哪些常见的协议</p>
                <div class="answer">
                    <p>
                        TCP：是面向连接的，保证数据质量

                        UDP：是尽可能大量传输数据的协议
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>网络层有哪些重要的协议</p>
                <div class="answer">
                    <p>
                        IP：
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">

                <p>HTTP 和HTTPS 有什么区别？</p>
                <div class="answer">
                    <p>
                        主要的区别在于HTTPS 多了一个TLS/SSL 的加密过程，

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">

                <p>什么时候选择TCP，什么时候选择UDP</p>
                <div class="answer">
                    <p>
                        当我们想要及时通信的时候，选择UDP，比如传输视频，少个一两帧问题也不是很大，
                        但是当我们想要传输的精准和完全的时候，TCP会好很多，比如传输文件，和邮件等等
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>什么是关系型数据库？</p>
                <div class="answer">
                    <P>
                        顾名思义，关系型数据库（RDB，Relational
                        Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
            <div class="question">
                <p>索引的优缺点</p>
                <div class="answer">
                    <p>
                        优点：使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）,
                        这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低
                        SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



        </div>
    </section>

    <section id="topics">
        <div class="topic">
            <h2>web测试</h2>

            <div class="question">
                <p>描述用浏览器访问www.baidu.com 的过程</p>
                <div class="answer">
                    <p>
                        1,首先我们需要获取网站的ip地址，这点需要dns 来进行实现。
                        2，有了ip地址，我们就可以建立tcp链接，这里会进行三次握手。
                        3，有了连接以后，我们就可以发送http请求。
                        4，服务器处理请求，并返回一个http相应
                        5，浏览器接受http相应。
                        6，浏览器渲染http响应头中的html代码，显示给用户。
                        7，关闭连接。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是sql 注入，什么是跨站脚本，什么是跨站请求伪造</p>
                <div class="answer">
                    <P>sql 注入： 塞入一些sql语句来从数据库里面提取信息，比如在输密码框的地方里面
                        跨站脚本 ： 在网页的输入框中塞入一些javascript 代码
                        跨站请求伪造 ：利用用户的session 或者cookie，代替原本的用户去发送一些请求
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



        </div>
    </section>

    <section id="topics">
        <div class="topic">
            <h2>软件工程与设计模式</h2>
            <div class="question">
                <p>你如何描述测试驱动开发（TDD）的工作流程</p>
                <div class="answer">
                    <p>红色阶段 (Red): 首先，为一个新功能编写一个失败的测试。
                        绿色阶段 (Green): 接着，尽量简单地编写代码，使得测试通过。
                        重构阶段 (Refactor): 最后，对代码进行重构，确保其简洁并没有重复，同时保证所有测试仍然通过</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>在Scrum中，产品负责人、Scrum Master和开发团队之间的主要责任和角色是什么？</p>
                <div class="answer">
                    <p>产品负责人 (Product Owner): 负责确定产品的功能、优先级和方向。他们与客户沟通，制定产品需求，并管理产品待办事项列表（Product Backlog）。
                        Scrum Master: 负责确保Scrum流程得到遵循和优化。他们帮助团队解决障碍，确保团队生产力，并与产品负责人和开发团队之间建立桥梁。
                        开发团队 (Development Team): 负责实施产品待办事项列表中的项目，设计、开发、测试并交付高质量的软件</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

        </div>
    </section>


    <section id="topics">
        <div class="topic">
            <h2>系统设计与体系结构</h2>

            <div class="question">
                <p>什么是cap理论，这个理论是干啥的</p>
                <div class="answer">
                    <p>CAP
                        理论在分布式系统设计中有着重要的指导意义。它帮助工程师和架构师理解在设计和运行分布式系统时可能会面临的权衡和折衷。例如，如果一个应用的关键需求是数据的一致性，并且可以接受偶尔的不可用，那么这个系统可能会更偏向于
                        CP；而如果一个应用要求始终可用，即使可能出现数据不完全一致的情况，那么这个系统可能会更偏向于 AP。
                    </p>
                    <P>
                        总的来说，就是指导架构师架构的一个理论，我们进行架构的时候，有三个条件，满足其中两个，另外一个就必然不能满足，因此我们应该结合实际的情况用这个理论设计出最合适的架构。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是Paxos 算法，这个算法出现的意义主要是什么</p>
                <div class="answer">
                    <p>Paxos算法是一个分布式系统中的共识算法，用于在存在故障的节点的环境中达成一致意见。它是由Leslie
                        Lamport在1989年提出的，但这个算法直到Lamport在1998年发布一篇更加直观的解释后才变得广为人知。。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是Raft 算法，这个算法的主要贡献和作用是什么，在分布式中扮演着什么样的角色</p>
                <div class="answer">
                    <p>Raft 算法是一个为分布式系统设计的共识算法。其主要的目的是确保系统中的所有节点在某一时刻都可以达成某种共识或一致性。在分布式系统中，节点之间可能会出现故障或延迟，导致数据的不一致，Raft
                        算法就是为了解决这种问题而设计的</p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



        </div>
    </section>

    <section id="topics">
        <div class="topic">
            <h2>高性能</h2>

            <div class="question">
                <p>什么是分布式系统，给我几个例子</p>
                <div class="answer">
                    <P>分布式数据库：如Cassandra、MongoDB和CockroachDB，它们都是设计成分布式架构的，可以在多个服务器上部署，实现数据的分片和复制。

                        计算框架：如Apache Hadoop和Spark，这些框架可以在集群中的多个节点上分布处理大数据任务。

                        分布式文件系统：如Google File System (GFS) 或 Apache HDFS，它们允许数据存储在多个节点上，提供高可用性和容错性。

                        云服务：如Amazon Web Services (AWS), Google Cloud Platform (GCP) 和 Microsoft
                        Azure，它们提供了分布式的计算、存储和其他服务。

                        分布式键值存储：如Redis、Etcd和Zookeeper，这些系统提供高性能、可伸缩的键值存储和其他功能。

                        Web技术：如负载均衡器和CDN (内容分发网络)，这些技术确保web内容可以高效、可靠地传递给全球的用</P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
            <div class="question">
                <p>什么是负载均衡</p>
                <div class="answer">
                    <p>负载均衡是分散到多个服务器上的工作负载的过程，以确保单一的服务器不会因为过多的请求而变得过载。这可以优化资源使用、最大化吞吐量、最小化响应时间，并确保系统在一个服务器故障时仍然可用。</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>
    </section>





    <section id="topics">
        <div class="topic">
            <h2>系统设计</h2>

            <div class="question">
                <p>认证 (Authentication) 和授权 (Authorization)的区别是什么？</p>
                <div class="answer">
                    <p>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication
                        被称为身份/用户验证。Authorization（授权） 发生在 Authentication（认证）
                        之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>RBAC 模型了解吗？</p>
                <div class="answer">
                    <p>
                        简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>Cookie 和 Session 有什么区别？</p>
                <div class="answer">
                    <p>

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是 Cookie ? Cookie 的作用是什么?</p>
                <div class="answer">
                    <p>
                        简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>如果没有 Cookie 的话 Session 还能用吗？</p>
                <div class="answer">
                    <p>
                        一般来讲的话，sessionid都存储在cookie 里面，如果客户端禁用了cookie，那么很可能sessionid
                        就使用不了了，但这种情况，我们也可以通过在url后面加入sessionId来解决。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以</p>
                <div class="answer">
                    <p>
                        我们与服务器建立连接后，服务器会生成一个sessionId，并把这个sessionId放到返回到客户端的cookie里面，因此，每次客户端发送请求都会带上这个sessionId，加入别人拿到了这个sessionId，就可以代替我们发送请求。

                        为什么token就可以呢， 因为我们登陆成功以后，token会放到我们的localstorage里面，每当我们发送请求的时候，我们带上的是这个localstorage里面的token。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>如何基于JWT做身份验证</p>
                <div class="answer">
                    <p>


                        1，用户向服务器发送账户和密码请求登陆。
                        2，如果登陆成功的话，服务器会生成相应的JWT
                        3，用户拿到JWT后，每次请求都会带上这个JWT
                        4，服务器可以从JWT中获取用户相关的信息。

                        建议把JWT放到localstorage而不是cookie当中防止CSRF的风险。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是SSO</p>
                <div class="answer">
                    <p>


                        指的就是在一套相互信任的用户系统当中，用户只用成功验证了其中一个，登陆其他的用户系统就不用再验证了

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>如何基于JWT做身份验证</p>
                <div class="answer">
                    <p>


                        1，用户向服务器发送账户和密码请求登陆。
                        2，如果登陆成功的话，服务器会生成相应的JWT
                        3，用户拿到JWT后，每次请求都会带上这个JWT
                        4，服务器可以从JWT中获取用户相关的信息。

                        建议把JWT放到localstorage而不是cookie当中防止CSRF的风险。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>





            <div class="question">
                <p>RBAC 模型了解吗？</p>
                <div class="answer">
                    <p>
                        简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>RBAC 模型了解吗？</p>
                <div class="answer">
                    <p>
                        简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是 JWT?，JWT 由哪些部分组成，如何基于 JWT 进行身份验证</p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是 JWT?，JWT 由哪些部分组成，如何基于 JWT 进行身份验证</p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是 JWT?，JWT 由哪些部分组成，如何基于 JWT 进行身份验证</p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>
    </section>





    <section id="topics">
        <div class="topic">
            <h2>系统设计</h2>
            <div class="question">
                <p>系统设计怎么做</p>
                <div class="answer">
                    <p>1，问清楚要求。 2，进行初步设计。 3，进行优化
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>系统设计关键指标，响应时间，并发数，QPS和TPS，吞吐量都是啥
                </p>
                <div class="answer">
                    <p>
                        1，响应时间是指用户发送请求到得到反应的时间。
                        2，并发数量：系统能同时供多少人进行访问和使用
                        3，QPS：服务器每秒可以执行的查询数量
                        4，TPS：服务器每秒处理的事务数量
                        5，吞吐量： 系统单位时间内处理的请求数量
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>
    </section>





    <section id="topics">
        <div class="topic">
            <h2>Reddis</h2>
            <div class="question">
                <p>为什么要使用缓存</p>
                <div class="answer">
                    <p>缓存的基本思想就是空间换时间，和这个道理相似的还有索引，索引的原理是把特殊的字段提取出来当成数据结构使用，这样的好处是可以大大减少检索的时间</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>常见的缓存策略有哪几种</p>
                <div class="answer">
                    <P>
                        cache aside pattern（旁路缓存模式）
                        这种模式下的写 ： 1，先往database里写数据，2，然乎删除cache里面的数据
                        读 ： 1，从cache里读数据，有就直接放回。2，cache里面没有的话，就把database里面的数据返回 3，最后再把cache里面的数据更新。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>

                <p>针对上面的这个策略， 为什么写的时候是删除cache而不是更新cache</p>
                <div class="answer">
                    <P>
                        因为删除cache更加的直接，你如果更新的缓存没有被访问，那就是浪费资源的表现，不如直接删了
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>


                <p>那么上面的这个策略的缺陷是什么呢</p>
                <div class="answer">
                    <P>

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


        </div>
    </section>





    <section id="topics">
        <div class="topic">
            <h2>mysql</h2>
            <div class="question">
                <p>说说mysql的架构</p>
                <div class="answer">
                    <p>1,client
                        2,连接器： 管理认证。
                        3,分析器： 分析sql语法
                        4,优化器： 索引选择
                        5,执行器： 操作引擎，返回结果</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>说说一句sql在mysql中的执行流程</p>
                <div class="answer">
                    <p>先连接数据库，然后进行sql分析，接着查询缓存，如果有的话直接返回，没有的话进行优化后让执行器执行sql，从存储引擎中返回数据</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>数据库中的事务是什么，简单概括下</p>
                <div class="answer">
                    <p>数据库中的事务（Transaction）是一个或一系列操作组成的一个完整的工作单元，这些操作要么全部完成，要么全部不做（原子性）
                        原子性（Atomicity）：事务中的所有操作都是不可分割的单元，要么全部完成，要么全部不完成。

                        一致性（Consistency）：事务应确保数据库的状态从一个一致的状态转变为另一个一致的状态。事务开始和结束时，数据库的完整性约束没有被破坏。

                        隔离性（Isolation）：在事务完成之前，它做出的任何修改对其他事务都是不可见的。即事务的执行不受其他事务的干扰。

                        持久性（Durability）：一旦事务完成（提交），它所做的修改就是永久性的，即使发生故障，修改的数据也不会丢失。

                        <br>
                        指的一提的是，在这里，通常AID是手段，C是目的。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>并发事务带来了哪些问题</p>
                <div class="answer">

                    <p>
                        1，脏读：一个事务读到了另外一个还没有提交的事务的数据。
                        2，不可重复读： 在同一个事务周期内，读到同一个数据返回的数据不一致
                        3，幻读：一个事务在读的时候，另一个事务突然往里面插入了数据，这个导致的就是一开始的事务读到了原本不在那里的数据。
                        4，丢失更新：两个事务同时更新一条记录，并且后一个事务的更新覆盖了前面一个事务的更新。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是MVCC，有什么用，原理是啥， 用简短的语言回答</p>
                <div class="answer">
                    <P>
                        MVCC是一种用于管理数据库并访问的技术，其核心是让多个用户能够同时访问数据库中的数据，而不会互相阻塞。

                        有什么作用：
                        1，允许数据在没有被锁的情况下被多个用户访问。
                        2，一致性：通过给数据提供一个快照的功能， 使得每个用户看到的数据的版本都是一样的。

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>共享锁和拍他锁的区别</p>
                <div class="answer">
                    <p>
                        共享锁： 允许一个事务去读一行数据，其他事务也可通过增加共享锁来读这一行数据

                        拍他锁： 允许一个事务去读和写一行数据，并排斥其他事务来进行这个操作。

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是MVCC，有什么用，原理是啥， 用简短的语言回答</p>
                <div class="answer">
                    <P>
                        MVCC是一种用于管理数据库并访问的技术，其核心是让多个用户能够同时访问数据库中的数据，而不会互相阻塞。

                        有什么作用：
                        1，允许数据在没有被锁的情况下被多个用户访问。
                        2，一致性：通过给数据提供一个快照的功能， 使得每个用户看到的数据的版本都是一样的。

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>索引是什么， 优缺点有啥</p>
                <div class="answer">
                    <p>
                        索引是一种帮忙更快抽取数据的数据结构，本质上是一种排好序的数据结构
                        优点：加快查找数据的速度。
                        缺点： 1，需要维护。 2，需要用物理文件进行储存。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么使用B+树</p>
                <div class="answer">
                    <p>
                        1，因为hash set无法进行范围查询。
                        2，因为二叉树容易退化成链表。
                        3，因为avl树的节点只能存储一个数据，需要重复的IO操作。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>你sql 都是怎么优化的</p>
                <div class="answer">
                    <p>
                        1，因为hash set无法进行范围查询。
                        2，因为二叉树容易退化成链表。
                        3，因为avl树的节点只能存储一个数据，需要重复的IO操作。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>mysql 常见的日志都有什么用</p>
                <div class="answer">
                    <p>
                        慢查询日志： 执行时间超过long_query_time的查询，解决SQL慢查询问题的时候会用到
                        一般查询日志：
                        二进制日志： 主要记录的是更改数据库的sql语句
                        错误日志： 记录服务器的异常启动和关闭。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>mysql binlog 主要记录了什么，有什么用
                </p>
                <div class="answer">
                    <p>
                        binlog 主要记录了那些修改数据以及数据结构的sql 语句
                        用途：主要用于复制以及数据恢复
                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    redo 日志如何保证事务的持久性
                </p>
                <div class="answer">
                    <p>
                        当我们的事务执行之前，先将改动写入redo log，即使系统突然崩溃，我们也可以通过redo 日志来进行修复。
                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    事务的四个性质分别是什么

                </p>
                <div class="answer">
                    <p>
                        1，原子性： 原子性的意思就是事务要么完成，要么就不完成，如果中途发生错误，那么就会回滚

                        2，隔离性： 不同的事务之间所操作的数据内容是完全保密的

                        3，持久性： 当事务一旦完成，那么改动就会是永久的

                        4，一致性： 事务开始前和结束后，数据的完整性约束并没有被破坏

                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    不可重复读和幻读的区别是什么

                </p>
                <div class="answer">
                    <p>
                        不可重复读：这个意味着我们更多的是关注同一行的变化，同一行数据，读两次的结果不一样，只能是因为别的事务在中途改变了这一行数据。
                        幻读：这个关注的是整个table数量的变化，意味着别的事务突然插入了或者删除了某一行数据导致总数据量发生了改变。

                        这两个情况非常的特殊，为什么要区分开来是因为解决两个问题采用的方法不一样。
                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    sql标准定义了哪些事务隔离级别
                </p>
                <div class="answer">
                    <p>

                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    为什么可重复读还是避免不了幻读的问题
                </p>
                <div class="answer">
                    <p>

                        首先，可重复读以为着我们的事务对于读取的数据行有所锁定,但是并不能阻止别的事务加入新的数据，所以说不行

                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    redo 日志如何保证事务的持久性
                </p>
                <div class="answer">
                    <p>
                        当我们的事务执行之前，先将改动写入redo log，即使系统突然崩溃，我们也可以通过redo 日志来进行修复。
                    </p>


                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>
                    说一说mysql的索引吧
                </p>
                <div class="answer">
                    <p>

                        索引是一种数据结构，其优点就是可以大大加快检索速度，缺点就是随着数据量的增多，维护会变得越来越困难。


                        我们按照不同的维度对索引进行分类：

                        1，从数据结构的角度： 现在的我们一般都是采用B
                        或者B+树作为索引的底层数据结构，B+树的好处在于他每一层可以存很多个节点，以及每个节点放的放的只有键和指向数据的指针，意味着可以放更多的节点。
                        不过，以前的话，我们还经常拿二叉树，哈希表来做底层的数据结构。


                        2，从 ：这一部分我们可以分为聚族索引和非聚族索引，聚族索引就是数据和数据结构一起放的索引， 非聚族索引就是数据结构和底层数据分开的索引，底层我们放的是聚族索引的主键。

                        3， 从应用层面的角度 ： 我们有主键索引，复合索引，和覆盖索引，


                        聚族索引和非聚族索引需要看是哪个引擎怎么用的，innoDB就会区分这两个，另外的一个引擎就不会，全部就都是非聚族索引。

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    索引为什么使用B+树
                </p>
                <div class="answer">
                    <P>
                        哈希索引没有办法范围查询。
                        二叉树容易退化。
                        AVL树旋转太复杂
                        红黑树高度过高。
                        B树解决了树过高的问题。
                        B+树进一步降低高度，因为非叶节点只存索引，不存数据，并且叶子结点通过链表相连接。

                    </P>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    如何优化一下mysql
                </p>
                <div class="answer">
                    <p>
                        避免不走索引的场景
                        1，模糊查询，尽量避免%符号放在前面的情况
                        2，避免使用in 和not in
                        3，避免判断null，我们可以用字符‘0’ 来替代。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>




            <div class="question">
                <p>
                    如何分析sql的性能
                </p>
                <div class="answer">
                    <p>
                        我们可以使用explain指令。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    数据库三范式说一下吧
                </p>
                <div class="answer">
                    <p>

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    数据库设计通常分为哪几步
                </p>
                <div class="answer">
                    <p>
                        1,需求分析
                        2，概念设计：这一步主要是画E-R 图
                        3，逻辑化概念： 这一步主要是把E-R 图转换为表格
                        4，物理结构分析：这一步是选择我们想要的物理存储结构
                        5，数据库实施：写代码
                        6，维护
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    Nosql数据库有什么优势
                </p>
                <div class="answer">
                    <p>
                        1，灵活性：Nosql数据库提供灵活的架构，以便于更高效的开发，比如键-值配对

                        2，可扩展性： 我们可以通过分布式来分布管理硬件，以达到横向增加维度的效果，
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>
                    表级锁和行级锁了解吗
                </p>
                <div class="answer">
                    <p>
                        表级锁锁的是一整张表，行级锁锁的是某一行，因此行级锁的并发度更高，但是由于行级锁的粒度更小，所以管理锁的成本更高。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    共享锁和拍他锁呢
                </p>
                <div class="answer">
                    <p>
                        共享锁： 又称读锁，这个锁允许多个事务同时读取一个数据

                        拍他锁： 独占锁，当我们要修改一个数据的时候，不给其他的数据进行使用。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    意向锁又是什么
                </p>
                <div class="answer">
                    <p>
                        意向锁就是在锁之前让别的事务指导他要加锁了，目的是为了标识事务将来在某一事件会锁住这一行。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    what are database 3nfs
                </p>
                <div class="answer">
                    <p>
                        1, all columns are atmoic,
                        2, all non-key columns are fully-functional dependent on the prmary key.
                        3, there's no transitive dependency between non-key columns.
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    difference between primary key and foreign key
                </p>
                <div class="answer">
                    <P>
                        each table could have multiple foreign keys, and the value of foreign key could be null, or
                        replicatif.
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>
                    百万数据级别的删除需要注意什么
                </p>
                <div class="answer">
                    <P>

                        需要注意的是索引，索引是分开的文件，我们进行数据的增删改查都会引起对索引文件的操作，因此我们应该先删除索引文件，然后再删除数据

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>
                    数据库读写分离了解吗
                </p>
                <div class="answer">
                    <P>
                        大体来说就是把服务器分为主服务器和从服务器，一个负责只读，另外一个只负责写，这中间也会有同步数据的操作。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>





        </div>
    </section>




    <section id="topics">
        <div class="topic">
            <h2>Redis</h2>
            <div class="question">
                <p>什么是Redis</p>
                <div class="answer">
                    <p>Redis 是一个基于RAM存储的数据管理系统，由于是放在内存里面的，所以读写速度非常快
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>为什么要用Redis</p>
                <div class="answer">
                    <p>
                        高性能，当我们把数据放到内存里面的时候，计算机内部的硬件会把经常访问的数据从内存放到混存里面，所以我们的读写就可以变的很快。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>三种常用的缓存读写策略是什么</p>
                <div class="answer">
                    <p>

                        1,cache aside pattern（旁路缓存模式）
                        2,read/write through pattern
                        3,write behind pattern
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是RDB持久化
                </p>
                <div class="answer">
                    <P>
                        redis 可以通过创建快照来获取数据库在某一时间点的副本，这个副本可以发送到别的服务器上面，从而创建具有相同数据库的服务器， 也可以留在本地，等重新启动电脑的时候用。
                    </P>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是AOF持久化
                </p>
                <div class="answer">
                    <p>
                        每当redis 执行一条命令以后，redis就会把这条命令写到AOF的缓冲区里面，然后再写进AOF文件里面，最后再决定如何把这些变动从缓冲区写进入到硬盘中。
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>AOF工作的基本流程是什么
                </p>
                <div class="answer">
                    <P>
                        1.命令追加。
                        2，文件写入
                        3，文件同步
                        4，文件重写：这一步是当AOF 文件变得太大的时候，我们拿来重新构造AOF文件的。
                        5，加载文件：这一步是重启redis时，拿AOF文件来重新构造数据库的。
                    </P>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>如何选择AOF和RDB
                </p>
                <div class="answer">
                    <p>
                        Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF
                        引擎错误。如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。

                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>三种常用的缓存读写机制是什么
                </p>
                <div class="answer">
                    <p>
                        1. 旁路缓存（Cache Aside Pattern）
                        想象一下你在一个大图书馆。图书馆的管理员（程序）在需要一本书（数据）时，他首先会在图书馆的推车上（缓存）找这本书。

                        找到了：直接使用推车上的书。
                        没找到：走进书库（数据库），找到书，然后把它放到推车上，以备下次或者其他人用。
                        在这个模式中，管理员主动去书库找书，并更新推车。

                        2. 读写穿透（Read/Write Through）
                        在这个情况下，图书馆推车（缓存）和书库（数据库）之间有一个智能助手（缓存管理器）。

                        读穿透：管理员需要一本书时，只需告诉智能助手。如果推车上没有，助手会自动跑到书库去找，然后把它放到推车上，并给管理员。
                        写穿透：如果管理员有一本新书，他只需告诉智能助手。助手会把书直接存到书库中，保证书库的完整性，并选择是否更新推车。
                        在这个模式中，智能助手自动处理推车（缓存）和书库（数据库）之间的数据同步。

                        3. 异步缓存（Asynchronous Cache）
                        设想图书馆的推车（缓存）在晚上的闭馆时间进行更新。在白天：

                        管理员（程序）使用推车（缓存）上现有的书（数据）。
                        如果他发现一本新书，或者需要移除一本旧书，他会做一个记号（更新操作）。
                        到了晚上，清洁工（后台进程）按照记号，加入新书，移除旧书，以便第二天推车上的书是更新过的。

                        在这个模式中，推车的更新（缓存更新）和白天的工作（前台操作）是解耦的。

                        希望这些例子能够让你对这些缓存策略有更直观的理解！如果你有进一步的问题或者其他概念需要解释，随时告诉我
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>redis 为什么会有内存碎片
                </p>
                <div class="answer">
                    <p>
                        因为分配给数据的内存大于数据所需要的内存
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>redis 为什么会有内存碎片
                </p>
                <div class="answer">
                    <p>
                        因为分配给数据的内存大于数据所需要的内存
                    </p>

                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>





        </div>
    </section>





    <section id="topics">
        <div class="topic">
            <h2>计算机网络</h2>
            <div class="question">
                <p>#GET 和 POST 的区别</p>
                <div class="answer">
                    <p>
                        GET 和 POST 是 HTTP
                        协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：语义（主要区别）：GET
                        通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>PING 命令的作用是什么？</p>
                <div class="answer">
                    <p>
                        PING 命令的输出结果通常包括以下几部分信息：ICMP Echo Request（请求报文）信息：序列号、TTL（Time to Live）值。目标主机的域名或 IP
                        地址：输出结果的第一行。往返时间（RTT，Round-Trip Time）：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo
                        Reply（响应报文）的总时间，用来衡量网络连接的延迟。统计结果（Statistics）：包括发送的 ICMP 请求数据包数量、接收到的 ICMP
                        响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。如果 PING
                        对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对ICMP请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。#
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>DNS 的作用是什么？
                </p>
                <div class="answer">
                    <p>
                        DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。
                        在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么 DNS 就闪亮登场了。目前 DNS
                        的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，它可以在UDP或TCP协议之上运行，端口为 53 .



                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>TCP 与 UDP 的区别（重要）</p>
                <div class="answer">
                    <P>
                        tcp不用建立连接，udp不需要建立连接
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>应用层有哪些常见的协议</p>
                <div class="answer">
                    <p>
                        HTTP ： 超文本传输协议。
                        SMTP： 邮件传输协议。
                        FTP：文件传输协议
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>传输层有哪些常见的协议</p>
                <div class="answer">
                    <p>
                        TCP：是面向连接的，保证数据质量

                        UDP：是尽可能大量传输数据的协议
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>网络层有哪些重要的协议</p>
                <div class="answer">
                    <p>
                        IP：
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">

                <p>HTTP 和HTTPS 有什么区别？</p>
                <div class="answer">
                    <p>
                        主要的区别在于HTTPS 多了一个TLS/SSL 的加密过程，

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">

                <p>什么时候选择TCP，什么时候选择UDP</p>
                <div class="answer">
                    <p>
                        当我们想要及时通信的时候，选择UDP，比如传输视频，少个一两帧问题也不是很大，
                        但是当我们想要传输的精准和完全的时候，TCP会好很多，比如传输文件，和邮件等等
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>IP协议的作用是什么</p>
                <div class="answer">
                    <P>
                        属于网络层的协议，主要作用是定义数据包的格式， 对数据包进行路由和寻址，以便他们可以跨网络传输并且顺利到达目的地。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">

                <p>什么时候选择TCP，什么时候选择UDP</p>
                <div class="answer">
                    <p>
                        当我们想要及时通信的时候，选择UDP，比如传输视频，少个一两帧问题也不是很大，
                        但是当我们想要传输的精准和完全的时候，TCP会好很多，比如传输文件，和邮件等等
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">

                <p>http是基于TCP还是UDP的</p>
                <div class="answer">
                    <p>
                        当我们想要及时通信的时候，选择UDP，比如传输视频，少个一两帧问题也不是很大，
                        但是当我们想要传输的精准和完全的时候，TCP会好很多，比如传输文件，和邮件等等
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

        </div>
    </section>

    <section id="topics">
        <div class="topic">
            <h2>C++</h2>
            <div class="question">
                <p>C++const关键字

                </p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>


        <div class="topic">
            <h2>C++</h2>
            <div class="question">
                <p>c++内存是怎么分区的

                </p>
                <div class="answer">
                    <p>
                        1，代码区，这个区是专门放代码的。

                        2，栈区: 放变量和参数的

                        3，堆区:放动态分配的变量的

                        4，常量区：放常量的

                        5，全局静态区： 放全局变量和静态变量的。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    什么是野指针，什么是空悬指针
                </p>

                <div class="answer">
                    <P>
                        空悬指针就是当我们释放了指针指向的那一堆内存以后，仍然保留着这个指针,野指针就是不确定的指针。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    内存里面堆和栈的区别
                </p>

                <div class="answer">
                    <p>
                        区别就是，栈的内存管理是自动的，当我们调用局部函数的时候，变量会被推进栈里面，调用结束以后就会释放，但是堆的话需要手动开内存和手动释放。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>
                    什么是new和delete? 与C语言中的malloc和free有什么区别？
                </p>

                <div class="answer">
                    <P>
                        new用于在堆上动态分配内存，并返回指向该内存的指针。delete用于释放之前由new分配的内存。与C的malloc和free不同，new和delete也会调用对象的构造函数和析构函数。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>
                    什么是new和delete? 与C语言中的malloc和free有什么区别？
                </p>

                <div class="answer">
                    <P>
                        new用于在堆上动态分配内存，并返回指向该内存的指针。delete用于释放之前由new分配的内存。与C的malloc和free不同，new和delete也会调用对象的构造函数和析构函数。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>
                    为什么内存对齐是重要的？它对性能有何影响？
                </p>

                <div class="answer">
                    <p>
                        内存对齐是将数据放在特定地址，使其访问更加高效。不正确的对齐可能导致性能下降和未定义行为
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



        </div>
    </section>



    <section id="topics">
        <div class="topic">
            <h2>描述您使用C++或C#开发的最复杂的项目。您在项目中的角色是什么</h2>
            <div class="question">
                <p>测试</p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>


        <div class="topic">
            <h2>描述您使用C++或C#开发的最复杂的项目。您在项目中的角色是什么</h2>
            <div class="question">
                <p>您如何优化C++或C#代码以提高性能?</p>
                <div class="answer">
                    <p> 1, 算法和数据结构
                        2，减少不必要的IO 操作引擎，返回结果
                        3，内存优化： 减少分配不必要的内存
                        4，并行计算： 利用现在操作系统的多核我们可以进行多线程的任务。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>


        <div class="topic">
            <h2>C++</h2>
            <div class="question">
                <p>您如何优化C++或C#代码以提高性能?</p>
                <div class="answer">
                    <p> 1, 算法和数据结构
                        2，减少不必要的IO 操作引擎，返回结果
                        3，内存优化： 减少分配不必要的内存
                        4，并行计算： 利用现在操作系统的多核我们可以进行多线程的任务。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>如何增加代码的可读性和可维护性</p>
                <div class="answer">
                    <p>
                        1，注释
                        2，有意义的命名
                        3，代码结构
                        4，避免代码重复
                        5，
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>请解释多线程与并发在C++中的差异。</p>
                <div class="answer">
                    <p>
                        并发是指在重叠的时间段两个任务进行并且完成。
                        多线程是指一个任务用多个线程进行完成。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p> 什么是线程，他和进程有什么不同</p>
                <div class="answer">
                    <P>
                        线程是操作系统能够进行调度的最小单位，进程是一个包含多个线程的容器，他有自己独立的地址空间，代码和系统资源，线程共享所属进程的资源，而进程之间则相互独立。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p> 什么是数据竞争？如何在C++中避免它</p>
                <div class="answer">
                    <p>
                        数据竞争发生在多个线程想要访问或者更改某个资源，我们可以用mutex 锁来防止这种情况的发生。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p> 什么是线程池</p>
                <div class="answer">
                    <p>
                        数据竞争发生在多个线程想要访问或者更改某个资源，我们可以用mutex 锁来防止这种情况的发生。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p> 并行和并发有什么不同</p>
                <div class="answer">
                    <p>
                        concurrency 指的是一个cpu在多个任务之间来回切换，
                        parallism指的是多个cpu同时进行多个任务
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>面向对象三大特性是什么，解释一下</p>
                <div class="answer">
                    <p>
                        封装： 目的是为了隐藏类内部的细节，只暴露必要的接口给外部。
                        继承： 提高代码的复用性和可维护性，减少重复代码。
                        多态： 允许不同的对象使用相同的接口的时候，具有不同的实现特性

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>重载，重写，隐藏的区别</p>
                <div class="answer">
                    <p>
                        重载是指一个方法可以
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>虚函数，纯虚函数，和模版函数都是怎么样实现多态的</p>
                <div class="answer">
                    <p>
                        虚函数： 基类里面定义的virtual函数，我们在派生类里面进行实现
                        纯虚函数： 虚函数后面加上=0， 有纯虚函数的类一般都是抽象类。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p> </p>
                <div class="answer">
                    <p>
                        虚函数： 基类里面定义的virtual函数，我们在派生类里面进行实现
                        纯虚函数： 虚函数后面加上=0， 有纯虚函数的类一般都是抽象类。
                        模版类，模版函数

                        前面两个方法强调的是动态多态性，意思就是我们在执行的时候选择某一个方法，
                        模版类强调的是静态多态性，我们编译的时候会编译不同版本的函数和类。
                        前面两个方法是通过vtable来进行实现的，我们在vtable里面找到我们想要的函数进行执行，而当模版类被实力化的时候，我们的编译器会决定要编译哪个版本的类。


                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p> </p>
                <div class="answer">
                    <p>
                        虚函数： 基类里面定义的virtual函数，我们在派生类里面进行实现
                        纯虚函数： 虚函数后面加上=0， 有纯虚函数的类一般都是抽象类。
                        模版类，模版函数

                        前面两个方法强调的是动态多态性，意思就是我们在执行的时候选择某一个方法，
                        模版类强调的是静态多态性，我们编译的时候会编译不同版本的函数和类。
                        前面两个方法是通过vtable来进行实现的，我们在vtable里面找到我们想要的函数进行执行，而当模版类被实力化的时候，我们的编译器会决定要编译哪个版本的类。


                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么C++构造函数不能是虚函数</p>
                <div class="answer">
                    <p>
                        从语法层面来看，虚函数的作用主要是哪里给派生函数一个模版，允
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>为什么C++构造函数不能是虚函数</p>
                <div class="answer">
                    <P>
                        构造函数的目的是为了构造这个类的实例，所以我们调用构造函数的时候不是调用派生类的构造函数，而是调用基类的
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>C++类对象的初始化和析构顺序</p>
                <div class="answer">
                    <P>
                        初始化从调用基类的构造函数先开始，析构的顺序相反，从最底层的派生类的析构函数开始。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>C++的RAII是啥</p>
                <div class="answer">
                    <P>
                        resource acquisition is initialization

                        意思就是，当我们对象去申请资源并且使用的时候，这已经就是初始化了
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>C++的智能指针说一下吧</p>
                <div class="answer">
                    <p>
                        unique_ptr : 这个指针的作用是拥有所指向对象的唯一指针权

                        std::shared_ptr ： 多个shared_ptr可以共享同一个对象的所有权。对象只有在最后一个指向它的shared_ptr被销毁时才会被删除



                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>C++的重载，重写，隐藏说一下吧</p>
                <div class="answer">
                    <p>
                        重载指的是，
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
            <div class="question">
                <p< /p>
                    <div class="answer">
                        <p>
                            虚函数： 基类里面定义的virtual函数，我们在派生类里面进行实现
                            纯虚函数： 虚函数后面加上=0， 有纯虚函数的类一般都是抽象类。
                            模版类，模版函数

                            前面两个方法强调的是动态多态性，意思就是我们在执行的时候选择某一个方法，
                            模版类强调的是静态多态性，我们编译的时候会编译不同版本的函数和类。
                            前面两个方法是通过vtable来进行实现的，我们在vtable里面找到我们想要的函数进行执行，而当模版类被实力化的时候，我们的编译器会决定要编译哪个版本的类。


                        </p>
                    </div>
                    <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


        </div>
    </section>



    <section id="topics">
        <div class="topic">
            <h2>系统设计</h2>
            <div class="question">
                <p></p>
                <div class="answer">
                    <p>测试</p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>
    </section>


    <section id="topics">
        <div class="topic">
            <h2>数据转化与ETL</h2>
            <div class="question">
                <p>FME的工作流程主要是什么</p>
                <div class="answer">
                    <P>
                        1, 需求分析
                        2，reader 读取数据
                        3，transformers 转换数据
                        4，writer 写入数据
                        5, 自动化流程
                        6，撰写文档

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>kafka 可以怎么样帮助FME，加快数据处理过程</p>
                <div class="answer">
                    <p>
                        在数据源头进行相应的处理，可以更快的进行高吞吐量的处理。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
        </div>
    </section>


    <section id="topics">
        <div class="topic">
            <h2>软件开发和软件工程基础概念</h2>
            <div class="question">
                <p>请简述软件开发生命周期的各个阶段</p>
                <div class="answer">
                    <P>
                        1，需求分析。
                        2，进行
                        3，写代码
                        4，测试
                        5，部署
                        6，维护


                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>CI/CD 解释一下，并且说一下jenkins 是如何工作的</p>
                <div class="answer">
                    <p>


                        持续集成和持续部署是软件工程里面很有用的环节
                        1，持续集成指的是每当我们有代码上传以后，我们在合并之前会进行自动化的测试

                        2，持续部署指的是确保这些新的更改能够快速有效的部署到生产环境中
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>说一下敏捷模型和瀑布模型吧
                </p>
                <div class="answer">
                    <p>
                        敏捷模型就是用小步伐，频率高的节奏去迭代式的开发产品，每次迭代后都能产出来一个可以工作的小功能或者产品部分，并且能够通过用户的反馈进行调整。
                        但是瀑布模型就是一个线性的模型了，一个阶段一个阶段的来，如果客户的需求经常变化的话，那么这个模型就会有他的弊端。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>





        </div>
    </section>

    <section id="topics">
        <div class="topic">
            <h2>待归类</h2>
            <div class="question">
                <p>请简述软件开发生命周期的各个阶段</p>
                <div class="answer">
                    <P>
                        1，需求分析。
                        2，进行
                        3，写代码
                        4，测试
                        5，部署
                        6，维护


                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>对称加密和不对称加密</p>
                <div class="answer">
                    <p>
                        一个用相同的钥匙加密和打开，
                        不对称加密采用不同的方式，先用公钥上锁，然后打开的那一方用私钥打开，公钥可以有多个
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>常见的网络安全攻击有哪些
                </p>
                <div class="answer">
                    <p>
                        Ddos攻击： 在这个范畴里，有http flood，udp flood, syn flood, 以及ip欺骗，

                        tcp 重置攻击： 像已建立的tcp连接发送一个伪造的TCP RST 重置包，导致其中指tcp 连接

                        dns flood ： 发送大量的dns 请求，导致dns服务器资源耗尽

                        中间人攻击： 中间人攻击就是A与B通信之间突然插进来了个C，篡改了他们原本想要通信的信息。


                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>C++ 指针和引用的区别
                </p>
                <div class="answer">
                    <P>
                        引用就是变量的别名，一旦使用了，还不可以重新赋值

                        但是指针不一样，指针可以重新赋值，并且存储的是另一个变量的地址

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>RAII 思想吧
                </p>
                <div class="answer">
                    <p>
                        RAII
                        的核心思想就是，当我们需要某个资源的时候，我们应该在对象的构造函数中申请他，而当我们不需要这个资源的时候，我们应该在析构函数中释放他，这样达到的目的就是资源的生命周期对象的生命周期就绑定在了一起。这样就不会有资源泄漏的问题

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是负载均衡，他的意义是啥
                </p>
                <div class="answer">
                    <p>
                        负载均衡的意义在于把流量均衡的分配到每个服务器之中

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是ARP和其作用？
                </p>
                <div class="answer">
                    <p>
                        ARP的作用在于把ip地址转换为MAC 地址，当他需要另一个设备的mac地址的时候，他会发送一个请求来获取mac地址
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是NAT
                </p>
                <div class="answer">
                    <p>
                        这个可以使私有的ip地址转换为共有的ip地址，意思就是多个私有的ip地址也可以使用相同的公共地址，主要通过路由器来实现。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>





        </div>



        <div class="topic">
            <h2>web socket 和http协议有什么不同
            </h2>
            <div class="question">
                <p>请简述软件开发生命周期的各个阶段</p>
                <div class="answer">
                    <P>
                        1，需求分析。
                        2，进行
                        3，写代码
                        4，测试
                        5，部署
                        6，维护


                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>








        </div>






    </section>

    <section id="topics">
        <div class="topic">
            <h2>MONGODB</h2>
            <div class="question">
                <p>MongoDB 是啥</p>
                <div class="answer">
                    <p>
                        mongoDB 是一个分布式储存的开源Nosql 数据存储系统，提供全面的面向文档储存方式。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>MongoDB 的储存结构是啥</p>
                <div class="answer">
                    <p>
                        文档，集合和数据库
                        一个集合里面有多个文档，一个数据库里面有多个集合。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>MongoDB 的储存结构是啥</p>
                <div class="answer">
                    <p>
                        文档，集合和数据库
                        一个集合里面有多个文档，一个数据库里面有多个集合。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>








    </section>


    <section id="topics">
        <div class="topic">
            <h2>操作系统</h2>
            <div class="question">
                <p>进程有哪些状态</p>
                <div class="answer">
                    <p>
                        总共有三个状态： 运行态，阻塞态，以及就绪态

                        在运行态的时候，我们如果等待某个事物的完成就会进入到阻塞态中，事件完成了以后，进程就会从阻塞态转换到就绪态，当我们的程序想要选择了就绪态的进程的时候，我们的进程就会跑到运行态

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>什么是僵尸进程和孤儿进程</p>
                <div class="answer">
                    <p>
                        僵尸进程指的是有些进程已经终止了，但在进程表里面还有记录，为什么会出现，是因为父进程调用子进程，子进程结束以后，父进程需要调用wait（）函数来终止子进程，所以僵尸进程就是父进程忘记调用结束的函数了。
                        孤儿进程就是父亲进程被终止了，但是他的一个或者多个子进程仍然在运行。
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是死锁，死锁产生的必要条件是什么</p>
                <div class="answer">
                    <P>
                        1，互斥条件：指的是线程对当前掌握到的资源进行斥他使用，及其他想用这个资源的线程必须进行等待。
                        2，请求并持有条件： 指的是一个线程持有了至少一个资源，又提出了新的资源请求，而新的资源已经被其他的线程所占有，所以当前线程会被阻塞。
                        3，不可剥夺条件： 及这个线程使用的资源不会被其他资源抢占，这个资源只会在这个线程使用结束以后被释放。
                        4，环路等待条件： 指在发生死锁的时候，必然存在一个线程-资源的环形链。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是死锁，死锁产生的必要条件是什么</p>
                <div class="answer">
                    <P>
                        1，互斥条件：指的是线程对当前掌握到的资源进行斥他使用，及其他想用这个资源的线程必须进行等待。
                        2，请求并持有条件： 指的是一个线程持有了至少一个资源，又提出了新的资源请求，而新的资源已经被其他的线程所占有，所以当前线程会被阻塞。
                        3，不可剥夺条件： 及这个线程使用的资源不会被其他资源抢占，这个资源只会在这个线程使用结束以后被释放。
                        4，环路等待条件： 指在发生死锁的时候，必然存在一个线程-资源的环形链。

                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么是虚拟内存</p>
                <div class="answer">
                    <p>
                        虚拟内存是一种机制，目的是为了把不同进程的虚拟地址和不同内存的物流地址给映射起来,程序所使用的内存地址叫做虚拟地址，实际在硬件空间里面的地址叫做物理内存地址。

                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

            <div class="question">
                <p>什么是多级页表</p>
                <div class="answer">
                    <p>
                        多级页表是一种虚拟内存管理技术，目的是为了实现物理地址到虚拟地址之间的转换，中间并且通过页表分层来减少物理内存的使用
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>








    </section>



    <section id="topics">
        <div class="topic">
            <h2>software design patter</h2>
            <div class="question">
                <p>what's a design pattern</p>
                <div class="answer">
                    <p>
                        it's a description or template of how to solve a problem that can be reused in many similar
                        situations.
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



            <div class="question">
                <p>difference between factory method and abstract factory</p>
                <div class="answer">
                    <p>
                        factory method is about create one object at a time, however, abstract factory creates a family
                        of dependents objects.
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p></p>
                <div class="answer">
                    <p>
                        factory method is about create one object at a time, however, abstract factory creates a family
                        of dependents objects.
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>



    </section>


    <section id="topics">
        <div class="topic">
            <h2>KAFKA</h2>
            <div class="question">
                <p>kafka是啥</p>
                <div class="answer">
                    <p>
                        kafka是一款负责处理高数据流的一款软件，用来处理高速流动的大量数据
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>


            <div class="question">
                <p>什么情况下我们会建议使用kafka</p>
                <div class="answer">
                    <p>
                        1， 消息系统
                        2， 用户活动跟踪
                        3， 记录运营指标
                    </p>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>

    </section>


    <section id="topics">
        <div class="topic">
            <h2>数据库的并发性</h2>
            <div class="question">
                <p></p>
                <div class="answer">
                    <P>
                        数据库的并发性指的是什么， 指的就是在多个用户访问数据库并进行改动的时候，我们需要保证数据库的一致性，完整性， 和排他性。具体的实现可以靠锁来实现，比如共享锁，拍他锁，乐观锁，悲观锁，等等。
                    </P>
                </div>
                <button onclick="toggleAnswer(this)">公布答案</button>
            </div>
    
    </section>






    <script>
        function toggleAnswer(buttonElement) {
            const answerDiv = buttonElement.previousElementSibling;

            // Check if the answer is currently displayed or not
            if (answerDiv.style.display === "none" || answerDiv.style.display === "") {
                answerDiv.style.display = "block";
                buttonElement.innerText = "收起答案";
            } else {
                answerDiv.style.display = "none";
                buttonElement.innerText = "公布答案";
            }
        }
    </script>

</body>

</html>